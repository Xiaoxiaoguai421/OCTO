                                                浅谈C/C++中的（堆）内存泄露
1.什么是内存泄露（Memory leak）
  在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，
  而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。
                                                                                                   --维基百科
2.内存泄露的危害
  在小程序中不会产生太大问题，当程序需要24h运行时将迅速产生巨大的内存泄漏，最终导致系统因内存被吃光而崩溃。
3.产生内存泄漏的原因
  动态申请的堆内存在使用后，未被释放
4.常见事故现场
  (1).在函数出口处未释放申请的堆内存
      C/C++可以在函数的任意位置退出，程序在函数起始位置申请动态内存，在函数尾释放前堆内存前便离开函数。（函数尾部的释放语句未执行）
      void Func(int num)
      {
          char *p=(char*)malloc(sizeof(char)*num)
          //code...
          if(!Function_1()){
              MessageBox("error!");
              return;   //此处退出导致未释放p所指内存空间
          }
          //code...
          free(p);
      }
      解决：释放内存不一定要放到函数尾，可以放在可能的函数出口处
  (2).喜新厌旧
      重复申请内存，改变指针时未保存所指内存的地址
      void Func(int num)
      {
           char *p=new char[num];
           p=new char[num];   //重复申请内存，导致第一次申请的内存泄漏，再也找不到了
           //code...
           p=q;   //失去对p原先所指空间的控制
      }
      解决：加一个指针记录原先所指地址
      ps:重复delete指针可能会使程序崩溃。delete并不改变指针的值，但是第二次delete的时候，行为未定义。
  (3).单飞
      malloc()和free()，new和delete，new[]和delete[]应配对使用（有借有还，再借不难），常见析构函数的种种错误（待完善）。
      特别地，delete不能想当然地去释放new[]申请的堆空间
  (4).野指针
      野指针不是NULL指针，使指向“垃圾”内存的指针。
	  产生原因：1.指针变量未被初始化。任何指针变量在刚被创建时的缺省值都是随机的，乱指一气。
	  			2.指针p在被free或者delete之后没有置为NULL，让p看起来像合法指针。
				3.指针操作超越了变量的作用范围。(有的编译器可能会通过这种操作，使得程序正常）
